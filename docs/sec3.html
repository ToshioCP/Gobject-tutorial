  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <title>GObject tutorial</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre{overflow: visible;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::after
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {   }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      div.sourceCode { margin: 10px; padding: 16px 10px 8px 10px; border: 2px solid silver; background-color: ghostwhite; overflow-x:scroll}
      pre:not(.sourceCode) { margin: 10px; padding: 16px 10px 8px 10px; border: 2px solid silver; background-color: ghostwhite; overflow-x:scroll}
      table {margin-left: auto; margin-right: auto; border-collapse: collapse; border: 1px solid;}
      th {padding: 2px 6px; border: 1px solid; background-color: ghostwhite;}
      td {padding: 2px 6px; border: 1px solid;}
      img {display: block; margin-left: auto; margin-right: auto;}
      figcaption {text-align: center;}
    </style>
  </head>
  <body style="padding-top: 70px;">
    <div class="container">
    <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
      <div class="container-fluid">
        <span class="navbar-brand">GObject tutorial</span>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
<a class="nav-link" href="index.html">Home</a>
</li>

            <li class="nav-item">
<a class="nav-link" href="sec2.html">Prev: section2</a>
</li>

            <li class="nav-item">
<a class="nav-link" href="sec4.html">Next: section4</a>
</li>

          </ul>
        </div>
      </div>
    </nav>
<h1 id="type-system-and-registration-process">Type system and
registration process</h1>
<p>GObject is a base object. We don’t usually use GObject itself.
Because GObject is very simple and not enough to be used by itself in
most situations. Instead, we use descendant objects of GObject such as
many kinds of GtkWidget. We can rather say such derivability is the most
important feature of GObject.</p>
<p>This section describes how to define a child object of GObject.</p>
<h2 id="name-convention">Name convention</h2>
<p>An example of this section is an object represents a real number. It
is not so useful because we have already had double type in C language
to represent real numbers. However, I think this example is not so bad
to know the technique how to define a child object.</p>
<p>First, you need to know the naming convention. An object name
consists of name space and name. For example, “GObject” consists of a
name space “G” and a name “Object”. “GtkWidget” consists of a name space
“Gtk” and a name “Widget”. Let the name space be “T” and the name be
“Double” of the new object. In this tutorial, we use “T” as a name space
for all the objects we make.</p>
<p>TDouble is the object name. It is a child object of GObject. It
represents a real number and the type of the number is double. It has
some useful functions.</p>
<h2 id="define-tdoubleclass-and-tdouble">Define TDoubleClass and
TDouble</h2>
<p>When we say “type”, it can be the type in the type system or C
language type. For example, GObject is a type name in the type system.
And char, int or double is C language types. When the meaning of the
word “type” is clear in the context, we just call it “type”. But if it’s
ambiguous, we call it “C type” or “type in the type system”.</p>
<p>TDouble object has the class and instance. The C type of the class is
TDoubleClass. Its structure is like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDoubleClass TDoubleClass<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> _TDoubleClass <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  GObjectClass parent_class<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>_TDoubleClass is a C structure tag name and TDoubleClass is “struct
_TDoubleClass”. TDoubleClass is a newly created C type.</p>
<ul>
<li>Use typedef to define a class type.</li>
<li>The first member of the structure must be the parent’s class
structure.</li>
</ul>
<p>TDoubleClass doesn’t need its own member.</p>
<p>The C type of the instance of TDouble is TDouble.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDouble TDouble<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> _TDouble <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  GObject parent<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This is similar to the structure of the class.</p>
<ul>
<li>Use typedef to define an instance type.</li>
<li>The first member of the structure must be the parent’s instance
structure.</li>
</ul>
<p>TDouble has its own member, “value”. It is the value of TDouble
instance.</p>
<p>The coding convention above needs to be kept all the time.</p>
<h2 id="creation-process-of-a-child-of-gobject">Creation process of a
child of GObject</h2>
<p>The creation process of TDouble type is similar to the one of
GObject.</p>
<ol type="1">
<li>Registers TDouble type to the type system.</li>
<li>The type system allocates memory for TDoubleClass and TDouble.</li>
<li>Initializes TDoubleClass.</li>
<li>Initializes TDouble.</li>
</ol>
<h2 id="registration">Registration</h2>
<p>Usually registration is done by convenient macro such as
<code>G_DECLARE_FINAL_TYPE</code> and <code>G_DEFINE_TYPE</code>. You
can use <code>G_DEFINE_FINAL_TYPE</code> for a final type class instead
of <code>G_DEFINE_TYPE</code> since GLib version 2.70. So you don’t need
to care about registration details. But, in this tutorial, it is
important to understand GObject type system, so I want to show you the
registration without macro, first.</p>
<p>There are two kinds of types, static and dynamic. Static type doesn’t
destroy its class even after all the instances have been destroyed.
Dynamic type destroys its class when the last instance has been
destroyed. The type of GObject is static and its descendant objects’
type is also static. The function <code>g_type_register_static</code>
registers a type of a static object. The following code is extracted
from <code>gtype.h</code> in the Glib source files.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>GType</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>g_type_register_static <span class="op">(</span>GType           parent_type<span class="op">,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">const</span> gchar     <span class="op">*</span>type_name<span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">const</span> GTypeInfo <span class="op">*</span>info<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                        GTypeFlags      flags<span class="op">);</span></span></code></pre></div>
<p>The parameters above are:</p>
<ul>
<li>parent_type: Parent type.</li>
<li>type_name: The name of the type. For example, “TDouble”.</li>
<li>info: Information of the type. <code>GTypeInfo</code> structure will
be explained below.</li>
<li>flags: Flag. If the type is abstract type or abstract value type,
then set their flag. Otherwise, set it to zero.</li>
</ul>
<p>Because the type system maintains the parent-child relationship of
the type, <code>g_type_register_static</code> has a parent type
parameter. And the type system also keeps the information of the type.
After the registration, <code>g_type_register_static</code> returns the
type of the new object.</p>
<p><code>GTypeInfo</code> structure is defined as follows.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> _GTypeInfo  GTypeInfo<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> _GTypeInfo</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* interface types, classed types, instantiated types */</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  guint16                class_size<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  GBaseInitFunc          base_init<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  GBaseFinalizeFunc      base_finalize<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* interface types, classed types, instantiated types */</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  GClassInitFunc         class_init<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  GClassFinalizeFunc     class_finalize<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  gconstpointer          class_data<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* instantiated types */</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  guint16                instance_size<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  guint16                n_preallocs<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  GInstanceInitFunc      instance_init<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* value handling */</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> GTypeValueTable  <span class="op">*</span>value_table<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This structure needs to be created before the registration.</p>
<ul>
<li>class_size: The size of the class. For example, TDouble’s class size
is <code>sizeof (TDoubleClass)</code>.</li>
<li>base_init, base_finalize: These functions initialize/finalize the
dynamic members of the class. In many cases, they aren’t necessary, and
are assigned NULL. For further information, see <a
href="https://docs.gtk.org/gobject/callback.BaseInitFunc.html">GObject
API Reference – BaseInitFunc</a> and <a
href="https://docs.gtk.org/gobject/callback.ClassInitFunc.html">GObject
API Reference – ClassInitFunc</a>.</li>
<li>class_init: Initializes static members of the class. Assign your
class initialization function to <code>class_init</code> member. By
convention, the name is
<code>&lt;name space&gt;_&lt;name&gt;_class_init</code>, for example,
<code>t_double_class_init</code>.</li>
<li>class_finalize: Finalizes the class. Because descendant type of
GObjec is static, it doesn’t have a finalize function. Assign NULL to
<code>class_finalize</code> member.</li>
<li>class_data: User-supplied data passed to the class init/finalize
functions. Usually NULL is assigned.</li>
<li>instance_size: The size of the instance. For example, TDouble’s
instance size is <code>sizeof (TDouble)</code>.</li>
<li>n_preallocs: This is ignored. it has been used by the old version of
Glib.</li>
<li>instance_init: Initializes instance members. Assign your instance
initialization function to <code>instance_init</code> member. By
convention, the name is
<code>&lt;name space&gt;_&lt;name&gt;_init</code>, for example,
<code>t_double_init</code>.</li>
<li>value_table: This is usually only useful for fundamental types. If
the type is descendant of GObject, assign NULL.</li>
</ul>
<p>These information is kept by the type system and used when the object
is created or destroyed. Class_size and instance_size are used to
allocate memory for the class and instance. Class_init and instance_init
functions are called when class or instance is initialized.</p>
<p>The C program <code>example3.c</code> shows how to use
<code>g_type_register_static</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDouble TDouble<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">struct</span> _TDouble <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  GObject parent<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="op">};</span></span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDoubleClass TDoubleClass<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">struct</span> _TDoubleClass <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  GObjectClass parent_class<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="op">};</span></span>
<span id="cb5-15"><a href="#cb5-15"></a></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>t_double_class_init <span class="op">(</span>TDoubleClass <span class="op">*</span>class<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>t_double_init <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a>GType</span>
<span id="cb5-25"><a href="#cb5-25"></a>t_double_get_type <span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>  <span class="dt">static</span> GType type <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>  GTypeInfo info<span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a>  <span class="cf">if</span> <span class="op">(</span>type <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-30"><a href="#cb5-30"></a>    info<span class="op">.</span>class_size <span class="op">=</span> <span class="kw">sizeof</span> <span class="op">(</span>TDoubleClass<span class="op">);</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>    info<span class="op">.</span>base_init <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>    info<span class="op">.</span>base_finalize <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>    info<span class="op">.</span>class_init <span class="op">=</span> <span class="op">(</span>GClassInitFunc<span class="op">)</span>  t_double_class_init<span class="op">;</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>    info<span class="op">.</span>class_finalize <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>    info<span class="op">.</span>class_data <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>    info<span class="op">.</span>instance_size <span class="op">=</span> <span class="kw">sizeof</span> <span class="op">(</span>TDouble<span class="op">);</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>    info<span class="op">.</span>n_preallocs <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>    info<span class="op">.</span>instance_init <span class="op">=</span> <span class="op">(</span>GInstanceInitFunc<span class="op">)</span>  t_double_init<span class="op">;</span></span>
<span id="cb5-39"><a href="#cb5-39"></a>    info<span class="op">.</span>value_table <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb5-40"><a href="#cb5-40"></a>    type <span class="op">=</span> g_type_register_static <span class="op">(</span>G_TYPE_OBJECT<span class="op">,</span> <span class="st">&quot;TDouble&quot;</span><span class="op">,</span> <span class="op">&amp;</span>info<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-41"><a href="#cb5-41"></a>  <span class="op">}</span></span>
<span id="cb5-42"><a href="#cb5-42"></a>  <span class="cf">return</span> type<span class="op">;</span></span>
<span id="cb5-43"><a href="#cb5-43"></a><span class="op">}</span></span>
<span id="cb5-44"><a href="#cb5-44"></a></span>
<span id="cb5-45"><a href="#cb5-45"></a><span class="dt">int</span></span>
<span id="cb5-46"><a href="#cb5-46"></a>main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-47"><a href="#cb5-47"></a>  GType dtype<span class="op">;</span></span>
<span id="cb5-48"><a href="#cb5-48"></a>  TDouble <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb5-49"><a href="#cb5-49"></a></span>
<span id="cb5-50"><a href="#cb5-50"></a>  dtype <span class="op">=</span> t_double_get_type <span class="op">();</span> <span class="co">/* or dtype = T_TYPE_DOUBLE */</span></span>
<span id="cb5-51"><a href="#cb5-51"></a>  <span class="cf">if</span> <span class="op">(</span>dtype<span class="op">)</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>    g_print <span class="op">(</span><span class="st">&quot;Registration was a success. The type is %lx.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> dtype<span class="op">);</span></span>
<span id="cb5-53"><a href="#cb5-53"></a>  <span class="cf">else</span></span>
<span id="cb5-54"><a href="#cb5-54"></a>    g_print <span class="op">(</span><span class="st">&quot;Registration failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb5-55"><a href="#cb5-55"></a></span>
<span id="cb5-56"><a href="#cb5-56"></a>  d <span class="op">=</span> g_object_new <span class="op">(</span>T_TYPE_DOUBLE<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb5-57"><a href="#cb5-57"></a>  <span class="cf">if</span> <span class="op">(</span>d<span class="op">)</span></span>
<span id="cb5-58"><a href="#cb5-58"></a>    g_print <span class="op">(</span><span class="st">&quot;Instantiation was a success. The instance address is %p.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> d<span class="op">);</span></span>
<span id="cb5-59"><a href="#cb5-59"></a>  <span class="cf">else</span></span>
<span id="cb5-60"><a href="#cb5-60"></a>    g_print <span class="op">(</span><span class="st">&quot;Instantiation failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb5-61"><a href="#cb5-61"></a>  g_object_unref <span class="op">(</span>d<span class="op">);</span> <span class="co">/* Releases the object d. */</span></span>
<span id="cb5-62"><a href="#cb5-62"></a></span>
<span id="cb5-63"><a href="#cb5-63"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-64"><a href="#cb5-64"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>16-22: A class initialization function and an instance
initialization function. The argument <code>class</code> points the
class structure and the argument <code>self</code> points the instance
structure. They do nothing here but they are necessary for the
registration.</li>
<li>24-43: <code>t_double_get_type</code> function. This function
returns the type of the TDouble object. The name of a function is always
<code>&lt;name space&gt;_&lt;name&gt;_get_type</code>. And a macro
<code>&lt;NAME_SPACE&gt;_TYPE_&lt;NAME&gt;</code> (all characters are
upper case) is replaced by this function. Look at line 3.
<code>T_TYPE_DOUBLE</code> is a macro replaced by
<code>t_double_get_type ()</code>. This function has a static variable
<code>type</code> to keep the type of the object. At the first call of
this function, <code>type</code> is zero. Then it calls
<code>g_type_register_static</code> to register the object to the type
system. At the second or subsequent call, the function just returns
<code>type</code>, because the static variable <code>type</code> has
been assigned non-zero value by <code>g_type_register_static</code> and
it keeps the value.</li>
<li>30-40 : Sets <code>info</code> structure and calls
<code>g_type_register_static</code>.</li>
<li>45-64: Main function. Gets the type of TDouble object and displays
it. The function <code>g_object_new</code> is used to instantiate the
object. The GObject API reference says that the function returns a
pointer to a GObject instance but it actually returns a gpointer.
Gpointer is the same as <code>void *</code> and it can be assigned to a
pointer that points any type. So, the statement
<code>d = g_object_new (T_TYPE_DOUBLE, NULL);</code> is correct. If the
function <code>g_object_new</code> returned <code>GObject *</code>, it
would be necessary to cast the returned pointer. After the creation, it
shows the address of the instance. Finally, the instance is released and
destroyed with the function <code>g_object_unref</code>.</li>
</ul>
<p><code>example3.c</code> is in the src/misc directory.</p>
<p>Execute it.</p>
<pre><code>$ cd src/misc; _build/example3
Registration was a success. The type is 56414f164880.
Instantiation was a success. The instance address is 0x56414f167010.</code></pre>
<h2 id="g_define_type-macro">G_DEFINE_TYPE macro</h2>
<p>The registration above is always done with the same algorithm.
Therefore, it can be defined as a macro such as
<code>G_DEFINE_TYPE</code>.</p>
<p><code>G_DEFINE_TYPE</code> does the following:</p>
<ul>
<li>Declares a class initialization function. Its name is
<code>&lt;name space&gt;_&lt;name&gt;_class_init</code>. For example, if
the object name is <code>TDouble</code>, it is
<code>t_double_class_init</code>. This is a declaration, not a
definition. You need to define it.</li>
<li>Declares a instance initialization function. Its name is
<code>&lt;name space&gt;_&lt;name&gt;_init</code>. For example, if the
object name is <code>TDouble</code>, it is <code>t_double_init</code>.
This is a declaration, not a definition. You need to define it.</li>
<li>Defines a static variable pointing to the parent class. Its name is
<code>&lt;name space&gt;_&lt;name&gt;_parent_class</code>. For example,
if the object name is <code>TDouble</code>, it is
<code>t_double_parent_class</code>.</li>
<li>Defines a <code>&lt;name space&gt;_&lt;name&gt;_get_type ()</code>
function. For example, if the object name is <code>TDouble</code>, it is
<code>t_double_get_type</code>. The registration is done in this
function like the previous subsection.</li>
</ul>
<p>Using this macro reduces lines of the program. See the following
sample <code>example4.c</code> which works the same as
<code>example3.c</code>.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDouble TDouble<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">struct</span> _TDouble <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>  GObject parent<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="op">};</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDoubleClass TDoubleClass<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">struct</span> _TDoubleClass <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>  GObjectClass parent_class<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="op">};</span></span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a>G_DEFINE_TYPE <span class="op">(</span>TDouble<span class="op">,</span> t_double<span class="op">,</span> G_TYPE_OBJECT<span class="op">)</span></span>
<span id="cb7-17"><a href="#cb7-17"></a></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>t_double_class_init <span class="op">(</span>TDoubleClass <span class="op">*</span>class<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>t_double_init <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24"></a><span class="op">}</span></span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="dt">int</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>  GType dtype<span class="op">;</span></span>
<span id="cb7-29"><a href="#cb7-29"></a>  TDouble <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb7-30"><a href="#cb7-30"></a></span>
<span id="cb7-31"><a href="#cb7-31"></a>  dtype <span class="op">=</span> t_double_get_type <span class="op">();</span> <span class="co">/* or dtype = T_TYPE_DOUBLE */</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>  <span class="cf">if</span> <span class="op">(</span>dtype<span class="op">)</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>    g_print <span class="op">(</span><span class="st">&quot;Registration was a success. The type is %lx.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> dtype<span class="op">);</span></span>
<span id="cb7-34"><a href="#cb7-34"></a>  <span class="cf">else</span></span>
<span id="cb7-35"><a href="#cb7-35"></a>    g_print <span class="op">(</span><span class="st">&quot;Registration failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb7-36"><a href="#cb7-36"></a></span>
<span id="cb7-37"><a href="#cb7-37"></a>  d <span class="op">=</span> g_object_new <span class="op">(</span>T_TYPE_DOUBLE<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb7-38"><a href="#cb7-38"></a>  <span class="cf">if</span> <span class="op">(</span>d<span class="op">)</span></span>
<span id="cb7-39"><a href="#cb7-39"></a>    g_print <span class="op">(</span><span class="st">&quot;Instantiation was a success. The instance address is %p.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> d<span class="op">);</span></span>
<span id="cb7-40"><a href="#cb7-40"></a>  <span class="cf">else</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>    g_print <span class="op">(</span><span class="st">&quot;Instantiation failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb7-42"><a href="#cb7-42"></a>  g_object_unref <span class="op">(</span>d<span class="op">);</span></span>
<span id="cb7-43"><a href="#cb7-43"></a></span>
<span id="cb7-44"><a href="#cb7-44"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-45"><a href="#cb7-45"></a><span class="op">}</span></span></code></pre></div>
<p>Thanks to <code>G_DEFINE_TYPE</code>, we are freed from writing
bothersome code like <code>GTypeInfo</code> and
<code>g_type_register_static</code>. One important thing to be careful
is to follow the convention of the naming of init functions.</p>
<p>Execute it.</p>
<pre><code>$ cd src/misc; _build/example4
Registration was a success. The type is 564b4ff708a0.
Instantiation was a success. The instance address is 0x564b4ff71400.</code></pre>
<p>You can use <code>G_DEFINE_FINAL_TYPE</code> instead of
<code>G_DEFINE_TYPE</code> for final type classes since GLib version
2.70.</p>
<h2 id="g_declare_final_type-macro">G_DECLARE_FINAL_TYPE macro</h2>
<p>Another useful macro is <code>G_DECLARE_FINAL_TYPE</code> macro. This
macro can be used for a final type. A final type doesn’t have any
children. If a type has children, it is a derivable type. If you want to
define a derivable type object, use
<code>G_DECLARE_DERIVABLE_TYPE</code> instead. However, you probably
want to write final type objects in most cases.</p>
<p><code>G_DECLARE_FINAL_TYPE</code> does the following:</p>
<ul>
<li>Declares <code>&lt;name space&gt;_&lt;name&gt;_get_type ()</code>
function. This is only declaration. You need to define it. But you can
use <code>G_DEFINE_TYPE</code>, its expansion includes the definition of
the function. So, you actually don’t need to write the definition by
yourself.</li>
<li>The C type of the object is defined as a typedef of structure. For
example, if the object name is <code>TDouble</code>, then
<code>typedef struct _TDouble TDouble</code> is included in the
expansion. But you need to define the structure
<code>struct _TDouble</code> by yourself before
<code>G_DEFINE_TYPE</code>.</li>
<li><code>&lt;NAME SPACE&gt;_&lt;NAME&gt;</code> macro is defined. For
example, if the object is <code>TDouble</code> the macro is
<code>T_DOUBLE</code>. It will be expanded to a function which casts the
argument to the pointer to the object. For example,
<code>T_DOUBLE (obj)</code> casts the type of <code>obj</code> to
<code>TDouble *</code>.</li>
<li><code>&lt;NAME SPACE&gt;_IS_&lt;NAME&gt;</code> macro is defined.
For example, if the object is <code>TDouble</code> the macro is
<code>T_IS_DOUBLE</code>. It will be expanded to a function which checks
if the argument points the instance of <code>TDouble</code>. It returns
true if the argument points a descendant of <code>TDouble</code>.</li>
<li>The class structure is defined. A final type object doesn’t need to
have its own member of class structure. The definition is like the line
11 to 14 in the <code>example4.c</code>.</li>
</ul>
<p>You need to write the macro definition of the type of the object
before <code>G_DECLARE_FINAL_TYPE</code>. For example, if the object is
<code>TDouble</code>, then</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span></code></pre></div>
<p>needs to be defined before <code>G_DECLARE_FINAL_TYPE</code>.</p>
<p>The C file <code>example5.c</code> uses this macro. It works like
<code>example3.c</code> or <code>example4.c</code>.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>G_DECLARE_FINAL_TYPE <span class="op">(</span>TDouble<span class="op">,</span> t_double<span class="op">,</span> T<span class="op">,</span> DOUBLE<span class="op">,</span> GObject<span class="op">)</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">struct</span> _TDouble <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>  GObject parent<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">};</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a>G_DEFINE_TYPE <span class="op">(</span>TDouble<span class="op">,</span> t_double<span class="op">,</span> G_TYPE_OBJECT<span class="op">)</span></span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>t_double_class_init <span class="op">(</span>TDoubleClass <span class="op">*</span>class<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>t_double_init <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="op">}</span></span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="dt">int</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>  GType dtype<span class="op">;</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>  TDouble <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a>  dtype <span class="op">=</span> t_double_get_type <span class="op">();</span> <span class="co">/* or dtype = T_TYPE_DOUBLE */</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>  <span class="cf">if</span> <span class="op">(</span>dtype<span class="op">)</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>    g_print <span class="op">(</span><span class="st">&quot;Registration was a success. The type is %lx.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> dtype<span class="op">);</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>  <span class="cf">else</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>    g_print <span class="op">(</span><span class="st">&quot;Registration failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-31"><a href="#cb10-31"></a></span>
<span id="cb10-32"><a href="#cb10-32"></a>  d <span class="op">=</span> g_object_new <span class="op">(</span>T_TYPE_DOUBLE<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>  <span class="cf">if</span> <span class="op">(</span>d<span class="op">)</span></span>
<span id="cb10-34"><a href="#cb10-34"></a>    g_print <span class="op">(</span><span class="st">&quot;Instantiation was a success. The instance address is %p.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> d<span class="op">);</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>  <span class="cf">else</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>    g_print <span class="op">(</span><span class="st">&quot;Instantiation failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-37"><a href="#cb10-37"></a></span>
<span id="cb10-38"><a href="#cb10-38"></a>  <span class="cf">if</span> <span class="op">(</span>T_IS_DOUBLE <span class="op">(</span>d<span class="op">))</span></span>
<span id="cb10-39"><a href="#cb10-39"></a>    g_print <span class="op">(</span><span class="st">&quot;d is TDouble instance.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-40"><a href="#cb10-40"></a>  <span class="cf">else</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>    g_print <span class="op">(</span><span class="st">&quot;d is not TDouble instance.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-42"><a href="#cb10-42"></a></span>
<span id="cb10-43"><a href="#cb10-43"></a>  <span class="cf">if</span> <span class="op">(</span>G_IS_OBJECT <span class="op">(</span>d<span class="op">))</span></span>
<span id="cb10-44"><a href="#cb10-44"></a>    g_print <span class="op">(</span><span class="st">&quot;d is GObject instance.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-45"><a href="#cb10-45"></a>  <span class="cf">else</span></span>
<span id="cb10-46"><a href="#cb10-46"></a>    g_print <span class="op">(</span><span class="st">&quot;d is not GObject instance.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-47"><a href="#cb10-47"></a>  g_object_unref <span class="op">(</span>d<span class="op">);</span></span>
<span id="cb10-48"><a href="#cb10-48"></a></span>
<span id="cb10-49"><a href="#cb10-49"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-50"><a href="#cb10-50"></a><span class="op">}</span></span></code></pre></div>
<p>Execute it.</p>
<pre><code>$ cd src/misc; _build/example5
Registration was a success. The type is 5560b4cf58a0.
Instantiation was a success. The instance address is 0x5560b4cf6400.
d is TDouble instance.
d is GObject instance.</code></pre>
<h2 id="separate-the-file-into-main.c-tdouble.h-and-tdouble.c">Separate
the file into main.c, tdouble.h and tdouble.c</h2>
<p>Now it’s time to separate the contents into three files,
<code>main.c</code>, <code>tdouble.h</code> and <code>tdouble.c</code>.
An object is defined by two files, a header file and C source file.</p>
<p>tdouble.h</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#pragma once</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>G_DECLARE_FINAL_TYPE <span class="op">(</span>TDouble<span class="op">,</span> t_double<span class="op">,</span> T<span class="op">,</span> DOUBLE<span class="op">,</span> GObject<span class="op">)</span></span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a>gboolean</span>
<span id="cb12-9"><a href="#cb12-9"></a>t_double_get_value <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>value<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="dt">void</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>t_double_set_value <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">,</span> <span class="dt">double</span> value<span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13"></a></span>
<span id="cb12-14"><a href="#cb12-14"></a>TDouble <span class="op">*</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>t_double_new <span class="op">(</span><span class="dt">double</span> value<span class="op">);</span></span></code></pre></div>
<ul>
<li>Header files are public, i.e. it is open to any files. Header files
include macros, which gives type information, cast and type check, and
public functions.</li>
<li>1: The directive <code>#pragma once</code> prevent the compiler from
reading the header file two times or more. It is not officially defined
but is supported widely in many compilers.</li>
<li>5-6: <code>T_TYPE_DOUBLE</code> is public.
<code>G_DECLARE_FINAL_TYPE</code> is expanded to public
definitions.</li>
<li>8-12: Public function declarations. They are getter and setter of
the value of the object. They are called “instance methods”, which are
used in object-oriented languages.</li>
<li>14-15: Object instantiation function.</li>
</ul>
<p>tdouble.c</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&quot;tdouble.h&quot;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">struct</span> _TDouble <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  GObject parent<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="op">};</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a>G_DEFINE_TYPE <span class="op">(</span>TDouble<span class="op">,</span> t_double<span class="op">,</span> G_TYPE_OBJECT<span class="op">)</span></span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>t_double_class_init <span class="op">(</span>TDoubleClass <span class="op">*</span>class<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="op">}</span></span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>t_double_init <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="op">}</span></span>
<span id="cb13-17"><a href="#cb13-17"></a></span>
<span id="cb13-18"><a href="#cb13-18"></a>gboolean</span>
<span id="cb13-19"><a href="#cb13-19"></a>t_double_get_value <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>  g_return_val_if_fail <span class="op">(</span>T_IS_DOUBLE <span class="op">(</span>self<span class="op">),</span> FALSE<span class="op">);</span></span>
<span id="cb13-21"><a href="#cb13-21"></a></span>
<span id="cb13-22"><a href="#cb13-22"></a>  <span class="op">*</span>value <span class="op">=</span> self<span class="op">-&gt;</span>value<span class="op">;</span></span>
<span id="cb13-23"><a href="#cb13-23"></a>  <span class="cf">return</span> TRUE<span class="op">;</span></span>
<span id="cb13-24"><a href="#cb13-24"></a><span class="op">}</span></span>
<span id="cb13-25"><a href="#cb13-25"></a></span>
<span id="cb13-26"><a href="#cb13-26"></a><span class="dt">void</span></span>
<span id="cb13-27"><a href="#cb13-27"></a>t_double_set_value <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">,</span> <span class="dt">double</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-28"><a href="#cb13-28"></a>  g_return_if_fail <span class="op">(</span>T_IS_DOUBLE <span class="op">(</span>self<span class="op">));</span></span>
<span id="cb13-29"><a href="#cb13-29"></a></span>
<span id="cb13-30"><a href="#cb13-30"></a>  self<span class="op">-&gt;</span>value <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb13-31"><a href="#cb13-31"></a><span class="op">}</span></span>
<span id="cb13-32"><a href="#cb13-32"></a></span>
<span id="cb13-33"><a href="#cb13-33"></a>TDouble <span class="op">*</span></span>
<span id="cb13-34"><a href="#cb13-34"></a>t_double_new <span class="op">(</span><span class="dt">double</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-35"><a href="#cb13-35"></a>  TDouble <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb13-36"><a href="#cb13-36"></a></span>
<span id="cb13-37"><a href="#cb13-37"></a>  d <span class="op">=</span> g_object_new <span class="op">(</span>T_TYPE_DOUBLE<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb13-38"><a href="#cb13-38"></a>  d<span class="op">-&gt;</span>value <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb13-39"><a href="#cb13-39"></a>  <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb13-40"><a href="#cb13-40"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>3-6: Declaration of the instance structure. Since
<code>G_DECLARE_FINAL_TYPE</code> macro emits
<code>typedef struct _TDouble TDouble</code>, the tag name of the
structure must be <code>_TDouble</code>.</li>
<li>8: <code>G_DEFINE_TYPE</code> macro.</li>
<li>10-16: class and instance initialization functions. At present, they
don’t do anything.</li>
<li>18-24: Getter. The argument <code>value</code> is the pointer to a
double type variable. Assigns the object value
(<code>self-&gt;value</code>) to the variable. If it succeeds, it
returns TRUE. The function <code>g_return_val_if_fail</code> is used to
check the argument type. If the argument <code>self</code> is not
TDouble type, it outputs error to the log and immediately returns FALSE.
This function is used to report a programmer’s error. You shouldn’t use
it for a runtime error. See <a
href="https://docs.gtk.org/glib/error-reporting.html">Glib API Reference
– Error Reporting</a> for further information. The function
<code>g_return_val_if_fail</code> isn’t used in static class functions,
which are private, because static functions are called only from
functions in the same file and the caller knows the type of
parameters.</li>
<li>26-31: Setter. The function <code>g_return_if_fail</code> is used to
check the argument type. This function doesn’t return any value. Because
the type of <code>t_double_set_value</code> is <code>void</code> so no
value will be returned. Therefore, we use <code>g_return_if_fail</code>
instead of <code>g_return_val_if_fail</code>.</li>
<li>33-40: Object instantiation function. It has one parameter
<code>value</code> to set the value of the object.</li>
<li>37: This function uses <code>g_object_new</code> to instantiate the
object. The argument <code>T_TYPE_DOUBLE</code> is expanded to a
function <code>t_double_get_type ()</code>. If this is the first call
for <code>t_double_get_type</code>, the type registration will be
carried out.</li>
</ul>
<p>main.c</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&quot;tdouble.h&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="dt">int</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>  TDouble <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>  d <span class="op">=</span> t_double_new <span class="op">(</span><span class="fl">10.0</span><span class="op">);</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>  <span class="cf">if</span> <span class="op">(</span>t_double_get_value <span class="op">(</span>d<span class="op">,</span> <span class="op">&amp;</span>value<span class="op">))</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    g_print <span class="op">(</span><span class="st">&quot;t_double_get_value succesfully assigned %lf to value.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>  <span class="cf">else</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>    g_print <span class="op">(</span><span class="st">&quot;t_double_get_value failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb14-14"><a href="#cb14-14"></a></span>
<span id="cb14-15"><a href="#cb14-15"></a>  t_double_set_value <span class="op">(</span>d<span class="op">,</span> <span class="op">-</span><span class="fl">20.0</span><span class="op">);</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>  g_print <span class="op">(</span><span class="st">&quot;Now, set d (tDouble object) with %lf.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">-</span><span class="fl">20.0</span><span class="op">);</span></span>
<span id="cb14-17"><a href="#cb14-17"></a>  <span class="cf">if</span> <span class="op">(</span>t_double_get_value <span class="op">(</span>d<span class="op">,</span> <span class="op">&amp;</span>value<span class="op">))</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>    g_print <span class="op">(</span><span class="st">&quot;t_double_get_value succesfully assigned %lf to value.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb14-19"><a href="#cb14-19"></a>  <span class="cf">else</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>    g_print <span class="op">(</span><span class="st">&quot;t_double_get_value failed.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>  g_object_unref <span class="op">(</span>d<span class="op">);</span></span>
<span id="cb14-22"><a href="#cb14-22"></a></span>
<span id="cb14-23"><a href="#cb14-23"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-24"><a href="#cb14-24"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>2: Includes <code>tdouble.h</code>. This is necessary for accessing
TDouble object.</li>
<li>9: Instantiate TDouble object and set <code>d</code> to point the
object.</li>
<li>10-13: Tests the getter of the object.</li>
<li>15-20: Tests the setter of the object.</li>
<li>21: Releases the instance <code>d</code>.</li>
</ul>
<p>The source files are located in src/tdouble1. Change your current
directory to the directory above and type the following.</p>
<pre><code>$ cd src/tdouble1
$ meson setup _build
$ ninja -C _build</code></pre>
<p>Then, execute the program.</p>
<pre><code>$ cd src/tdouble1; _build/example6
t_double_get_value succesfully assigned 10.000000 to value.
Now, set d (tDouble object) with -20.000000.
t_double_get_value succesfully assigned -20.000000 to value.</code></pre>
<p>This example is very simple. But any object has header file and C
source file like this. And they follow the convention. You probably
aware of the importance of the convention. For the further information
refer to <a
href="https://docs.gtk.org/gobject/concepts.html#conventions">GObject
API Reference – Conventions</a>.</p>
<h2 id="functions">Functions</h2>
<p>Functions of objects are open to other objects. They are like public
methods in object oriented languages. They are actually called “instance
method” in the GObject API Reference.</p>
<p>It is natural to add calculation operators to TDouble objects because
they represent real numbers. For example, <code>t_double_add</code> adds
the value of the instance and another instance. Then it creates a new
TDouble instance which has a value of the sum of them.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>TDouble <span class="op">*</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>t_double_add <span class="op">(</span>TDouble <span class="op">*</span>self<span class="op">,</span> TDouble <span class="op">*</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  g_return_val_if_fail <span class="op">(</span>T_IS_DOUBLE <span class="op">(</span>self<span class="op">),</span> NULL<span class="op">);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  g_return_val_if_fail <span class="op">(</span>T_IS_DOUBLE <span class="op">(</span>other<span class="op">),</span> NULL<span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> value<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span> t_double_get_value <span class="op">(</span>other<span class="op">,</span> <span class="op">&amp;</span>value<span class="op">))</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> t_double_new <span class="op">(</span>self<span class="op">-&gt;</span>value <span class="op">+</span> value<span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The first argument <code>self</code> is the instance the function
belongs to. The second argument <code>other</code> is another TDouble
instance.</p>
<p>The value of <code>self</code> can be accessed by
<code>self-&gt;value</code>, but don’t use <code>other-&gt;value</code>
to get the value of <code>other</code>. Use a function
<code>t_double_get_value</code> instead. Because <code>self</code> is an
instance out of <code>other</code>. Generally, the structure of an
object isn’t open to other objects. When an object A access to another
object B, A must use a public function provided by B.</p>
<h2 id="exercise">Exercise</h2>
<p>Write functions of TDouble object for subtraction, multiplication,
division and sign changing (unary minus). Compare your program to
<code>tdouble.c</code> in src/tdouble2 directory.</p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  </body>
  </html>
